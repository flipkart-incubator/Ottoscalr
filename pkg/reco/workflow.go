package reco

import (
	"context"
	"errors"
	"fmt"
	v1alpha1 "github.com/flipkart-incubator/ottoscalr/api/v1alpha1"
	"github.com/flipkart-incubator/ottoscalr/pkg/policy"
	"github.com/go-logr/logr"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	golog "log"
	"math"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/log/zap"
	p8smetrics "sigs.k8s.io/controller-runtime/pkg/metrics"
	"strconv"
	"time"
)

var (
	getRecoGenerationLatency = promauto.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "get_reco_generation_latency_seconds",
			Help:    "Time to generate recommendation in seconds",
			Buckets: append(prometheus.DefBuckets, 15, 20, 50, 100),
		}, []string{"namespace", "policyreco", "workloadKind", "workload"},
	)
)

func init() {
	p8smetrics.Registry.MustRegister(getRecoGenerationLatency)
}

type RecommendationWorkflow interface {
	Execute(ctx context.Context, wm WorkloadMeta) (*v1alpha1.HPAConfiguration, *v1alpha1.HPAConfiguration, *Policy, error)
}

type Recommender interface {
	Recommend(ctx context.Context, wm WorkloadMeta) (*v1alpha1.HPAConfiguration, error)
}

type RecommendationWorkflowImpl struct {
	k8sClient           client.Client
	recommender         Recommender
	policyIterators     map[string]PolicyIterator
	policyStore         policy.Store
	logger              logr.Logger
	minRequiredReplicas int
}

type WorkloadMeta struct {
	metav1.TypeMeta
	Name      string
	Namespace string
}

type RecoWorkflowBuilder RecommendationWorkflowImpl

func (b *RecoWorkflowBuilder) WithRecommender(r Recommender) *RecoWorkflowBuilder {
	if b.recommender == nil {
		b.recommender = r
		return b
	}
	golog.Println("Only one recommender must be added. There's already one configured so ignoring this one.")
	return b
}

func (b *RecoWorkflowBuilder) WithPolicyIterator(p PolicyIterator) *RecoWorkflowBuilder {
	if b.policyIterators == nil {
		b.policyIterators = make(map[string]PolicyIterator)
		b.policyIterators[p.GetName()] = p
	} else if _, ok := b.policyIterators[p.GetName()]; !ok {
		b.policyIterators[p.GetName()] = p
	}
	return b
}

func (b *RecoWorkflowBuilder) WithLogger(log logr.Logger) *RecoWorkflowBuilder {
	var zeroValLogger logr.Logger
	if b.logger == zeroValLogger {
		b.logger = log
	}
	return b
}

func (b *RecoWorkflowBuilder) WithMinRequiredReplicas(minRequiredReplicas int) *RecoWorkflowBuilder {
	b.minRequiredReplicas = minRequiredReplicas
	return b
}

func (b *RecoWorkflowBuilder) WithPolicyStore(policyStore policy.Store) *RecoWorkflowBuilder {
	b.policyStore = policyStore
	return b
}

func (b *RecoWorkflowBuilder) WithK8sClient(k8sClient client.Client) *RecoWorkflowBuilder {
	b.k8sClient = k8sClient
	return b
}

func (b *RecoWorkflowBuilder) Build() (RecommendationWorkflow, error) {
	var zeroValLogger logr.Logger
	if b.logger == zeroValLogger {
		b.logger = zap.New()
	}
	if b.recommender == nil && b.policyIterators == nil {
		return nil, errors.New("both recommender and policy iterators can't be nil")
	}
	if b.policyStore == nil || b.k8sClient == nil {
		return nil, errors.New("policy store or k8sClient can't be nil")
	}
	if b.minRequiredReplicas == 0 {
		b.minRequiredReplicas = 3
	}
	return &RecommendationWorkflowImpl{
		k8sClient:           b.k8sClient,
		recommender:         b.recommender,
		policyIterators:     b.policyIterators,
		logger:              b.logger,
		minRequiredReplicas: b.minRequiredReplicas,
		policyStore:         b.policyStore,
	}, nil
}

func NewRecommendationWorkflowBuilder() *RecoWorkflowBuilder {
	return &RecoWorkflowBuilder{}
}

func (rw *RecommendationWorkflowImpl) Execute(ctx context.Context, wm WorkloadMeta) (*v1alpha1.HPAConfiguration, *v1alpha1.HPAConfiguration, *Policy, error) {
	ctx = log.IntoContext(ctx, rw.logger)
	rw.logger.V(0).Info("Workload Meta", "workload", wm)
	if rw.recommender == nil {
		return nil, nil, nil, errors.New("No recommenders configured in the workflow.")
	}

	recoGenerationStartTime := time.Now()
	targetRecoConfig, err := rw.recommender.Recommend(ctx, wm)
	recoGenerationLatency := time.Since(recoGenerationStartTime).Seconds()
	getRecoGenerationLatency.WithLabelValues(wm.Namespace, wm.Name, wm.Kind, wm.Name).Observe(recoGenerationLatency)
	if err != nil {
		rw.logger.Error(err, "Error while generating recommendation")
		return nil, nil, nil, err
	}

	//Add a metric for the actual recommendation config generated by the recommendation
	targetRecoConfig = transformTargetRecoConfig(targetRecoConfig, rw.minRequiredReplicas)
	var nextPolicy *Policy
	for i, pi := range rw.policyIterators {
		rw.logger.V(0).Info("Running policy iterator", "iterator", i)
		p, err := pi.NextPolicy(ctx, wm)
		if err != nil {
			rw.logger.Error(err, "Error while generating recommendation")
			return nil, nil, nil, err
		}

		if p == nil {
			rw.logger.V(0).Info("Skipping this PI since it has recommended nil policy (no-op)", "iterator", i)
			continue
		}

		rw.logger.V(0).Info("Next Policy recommended by PI", "iterator", i, "policy", p)
		nextPolicy = pickSafestPolicy(nextPolicy, p)
		rw.logger.V(0).Info("Next Policy after applying PI", "iterator", i, "policy", nextPolicy)

	}

	nextConfig, policyToApply, err := rw.generateNextRecoConfig(targetRecoConfig, nextPolicy, wm)
	if err != nil {
		return nil, nil, nil, err
	}
	return nextConfig, targetRecoConfig, policyToApply, nil
}

func (rw *RecommendationWorkflowImpl) generateNextRecoConfig(config *v1alpha1.HPAConfiguration, policy *Policy, wm WorkloadMeta) (*v1alpha1.HPAConfiguration, *Policy, error) {
	applyReco, closestSafePolicy, err := rw.shouldApplyReco(config, policy, wm)
	if err != nil {
		return nil, nil, err
	}
	if applyReco {
		return config, closestSafePolicy, nil
	} else {
		recoConfig, _ := createRecoConfigFromPolicy(policy, config, wm)
		return recoConfig, policy, nil
	}
}

func createRecoConfigFromPolicy(policy *Policy, recoConfig *v1alpha1.HPAConfiguration, wm WorkloadMeta) (*v1alpha1.HPAConfiguration, error) {
	if policy == nil || recoConfig == nil {
		return nil, errors.New("Policy or reco config supplied is nil")
	}
	return &v1alpha1.HPAConfiguration{
		Min:               recoConfig.Max - int(math.Ceil(float64(policy.MinReplicaPercentageCut*(recoConfig.Max-recoConfig.Min)/100))),
		Max:               recoConfig.Max,
		TargetMetricValue: policy.TargetUtilization,
	}, nil
}

// Determines whether the recommendation should take precedence over the nextPolicy
func (rw *RecommendationWorkflowImpl) shouldApplyReco(config *v1alpha1.HPAConfiguration, policy *Policy, wm WorkloadMeta) (bool, *Policy, error) {
	if config == nil {
		return false, nil, nil
	}
	closestPolicy, err := rw.findClosestSafePolicy(config)
	if err != nil {
		return false, nil, fmt.Errorf("error finding closest safe policy for config: %v", config)
	}
	if policy == nil {
		return true, closestPolicy, nil
	}
	var policyReco v1alpha1.PolicyRecommendation
	err = rw.k8sClient.Get(context.Background(), types.NamespacedName{
		Name:      wm.Name,
		Namespace: wm.Namespace}, &policyReco)

	if err != nil {
		return false, nil, fmt.Errorf("error getting the policyreco: %s,namespace: %s, %v", wm.Name, wm.Namespace, err)
	}

	targetRecoAchieved := isTargetRecommendationAchieved(&policyReco)
	if (policy.RiskIndex > closestPolicy.RiskIndex) || (targetRecoAchieved && policy.RiskIndex == closestPolicy.RiskIndex) {
		return true, closestPolicy, nil
	} else {
		return false, nil, nil
	}
}

func pickSafestPolicy(p1, p2 *Policy) *Policy {
	// if either or both of the policies are nil
	if p1 == nil && p2 != nil {
		return p2
	} else if p2 == nil && p1 != nil {
		return p1
	} else if p1 == nil && p2 == nil {
		return nil
	}

	if p1.RiskIndex <= p2.RiskIndex {
		return p1
	} else {
		return p2
	}
}

func transformTargetRecoConfig(targetRecoConfig *v1alpha1.HPAConfiguration, minRequiredReplicas int) *v1alpha1.HPAConfiguration {
	if targetRecoConfig == nil {
		return nil
	}
	maxReplicas := targetRecoConfig.Max
	minReplicas := targetRecoConfig.Min
	if maxReplicas >= minRequiredReplicas && minReplicas < minRequiredReplicas {
		minReplicas = minRequiredReplicas
	}
	return &v1alpha1.HPAConfiguration{Min: minReplicas, Max: maxReplicas, TargetMetricValue: targetRecoConfig.TargetMetricValue}
}

func (rw *RecommendationWorkflowImpl) findClosestSafePolicy(config *v1alpha1.HPAConfiguration) (*Policy, error) {
	policies, err := rw.policyStore.GetSortedPolicies()
	if err != nil {
		return nil, err
	}
	var closestSafePolicy *v1alpha1.Policy

	for _, pc := range policies.Items {
		if pc.Spec.MinReplicaPercentageCut == 100 && (pc.Spec.TargetUtilization <= config.TargetMetricValue) {
			// pc is a loop variable and should not assign address of loop variable
			candidatePolicy := pc
			closestSafePolicy = &candidatePolicy
		}

	}

	if closestSafePolicy == nil {
		return nil, errors.New("closest safe policy not found")
	}
	return PolicyFromCR(closestSafePolicy), nil
}

func isTargetRecommendationAchieved(policyreco *v1alpha1.PolicyRecommendation) bool {
	if policyreco == nil {
		return false
	}
	targetAchieved := false
	for _, condition := range policyreco.Status.Conditions {
		if condition.Type == string(v1alpha1.TargetRecoAchieved) {
			targetAchieved, _ = strconv.ParseBool(string(condition.Status))
			return targetAchieved
		}
	}
	return targetAchieved
}
